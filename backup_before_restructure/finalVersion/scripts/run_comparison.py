#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\n统一测试脚本 - 比较不同算法的性能\n\"\"\"\nimport sys\nimport argparse\nimport time\nfrom pathlib import Path\n\n# 添加项目路径\nproject_root = Path(__file__).parent.parent\nsys.path.append(str(project_root))\nsys.path.append(str(project_root.parent))\n\nfrom src.algorithms import OriginalStruc2Vec, GraphletStruc2Vec, FusionStruc2Vec\nfrom src.utils import DataLoader, Evaluator\nfrom config.config import ALGORITHM_CONFIG, EVALUATION_CONFIG, ensure_directories\n\ndef parse_arguments():\n    \"\"\"解析命令行参数\"\"\"\n    parser = argparse.ArgumentParser(description='Struc2Vec 算法比较工具')\n    \n    parser.add_argument('--dataset', type=str, default='brazil-airports',\n                       choices=['brazil-airports', 'wiki', 'lastfm'],\n                       help='数据集名称')\n    \n    parser.add_argument('--methods', type=str, default='original,graphlet,fusion',\n                       help='要比较的方法，用逗号分隔 (original,graphlet,fusion)')\n    \n    parser.add_argument('--fusion-alpha', type=float, default=0.5,\n                       help='融合权重 α (默认: 0.5)')\n    \n    parser.add_argument('--fusion-method', type=str, default='weighted',\n                       choices=['weighted', 'min', 'max'],\n                       help='融合方法 (默认: weighted)')\n    \n    parser.add_argument('--classifiers', type=str, default='logistic',\n                       help='分类器，用逗号分隔 (logistic,svm,rf)')\n    \n    parser.add_argument('--workers', type=int, default=2,\n                       help='并行工作进程数 (默认: 2)')\n    \n    parser.add_argument('--num-walks', type=int, default=8,\n                       help='随机游走数量 (默认: 8)')\n    \n    parser.add_argument('--walk-length', type=int, default=40,\n                       help='随机游走长度 (默认: 40)')\n    \n    parser.add_argument('--embed-size', type=int, default=64,\n                       help='嵌入维度 (默认: 64)')\n    \n    parser.add_argument('--iter', type=int, default=3,\n                       help='Word2Vec 迭代次数 (默认: 3)')\n    \n    parser.add_argument('--verbose', action='store_true',\n                       help='详细输出')\n    \n    parser.add_argument('--save-results', action='store_true',\n                       help='保存结果到文件')\n    \n    return parser.parse_args()\n\ndef create_algorithms(dataset_name, graph, args):\n    \"\"\"创建算法实例\"\"\"\n    algorithms = []\n    methods = [m.strip() for m in args.methods.split(',')]\n    \n    # 通用参数\n    common_params = {\n        'walk_length': args.walk_length,\n        'num_walks': args.num_walks,\n        'embed_size': args.embed_size,\n        'workers': args.workers,\n        'iter': args.iter,\n        'verbose': 1 if args.verbose else 0\n    }\n    \n    if 'original' in methods:\n        print(\"📝 创建原始 Struc2Vec 算法...\")\n        original = OriginalStruc2Vec(graph, **common_params)\n        algorithms.append(original)\n    \n    if 'graphlet' in methods:\n        print(\"📝 创建 Graphlet 增强 Struc2Vec 算法...\")\n        graphlet_params = common_params.copy()\n        graphlet_params.update({\n            'max_layer': 3,\n            'k': 5,\n            'distance_method': 'frobenius',\n            'use_orbit_selection': False\n        })\n        graphlet = GraphletStruc2Vec(graph, **graphlet_params)\n        algorithms.append(graphlet)\n    \n    if 'fusion' in methods:\n        print(f\"📝 创建融合 Struc2Vec 算法 ({args.fusion_method}, α={args.fusion_alpha})...\")\n        fusion_params = common_params.copy()\n        fusion_params.update({\n            'alpha': args.fusion_alpha,\n            'fusion_method': args.fusion_method\n        })\n        fusion = FusionStruc2Vec(graph, **fusion_params)\n        algorithms.append(fusion)\n    \n    return algorithms\n\ndef save_results(results, args, output_path):\n    \"\"\"保存结果到文件\"\"\"\n    import json\n    import pickle\n    from datetime import datetime\n    \n    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n    \n    # 保存JSON格式的结果摘要\n    summary = {\n        'timestamp': timestamp,\n        'dataset': args.dataset,\n        'methods': args.methods,\n        'parameters': vars(args),\n        'results_summary': results['comparison_report']\n    }\n    \n    json_file = output_path / f'comparison_results_{args.dataset}_{timestamp}.json'\n    with open(json_file, 'w', encoding='utf-8') as f:\n        json.dump(summary, f, indent=2, ensure_ascii=False)\n    \n    # 保存完整的pickle结果\n    pickle_file = output_path / f'comparison_results_{args.dataset}_{timestamp}.pkl'\n    with open(pickle_file, 'wb') as f:\n        pickle.dump(results, f)\n    \n    print(f\"\\n💾 结果已保存:\")\n    print(f\"   摘要: {json_file}\")\n    print(f\"   详细: {pickle_file}\")\n\ndef main():\n    \"\"\"主函数\"\"\"\n    # 解析参数\n    args = parse_arguments()\n    \n    # 确保目录存在\n    ensure_directories()\n    \n    print(\"=\" * 80)\n    print(\"🚀 Struc2Vec 算法比较工具\")\n    print(\"=\" * 80)\n    print(f\"数据集: {args.dataset}\")\n    print(f\"比较方法: {args.methods}\")\n    print(f\"分类器: {args.classifiers}\")\n    if 'fusion' in args.methods:\n        print(f\"融合参数: {args.fusion_method}, α={args.fusion_alpha}\")\n    \n    start_total = time.time()\n    \n    try:\n        # 加载数据\n        print(\"\\n📂 加载数据...\")\n        loader = DataLoader()\n        graph, (X, Y) = loader.load_dataset(args.dataset)\n        \n        # 创建算法\n        print(\"\\n🔧 创建算法实例...\")\n        algorithms = create_algorithms(args.dataset, graph, args)\n        \n        if not algorithms:\n            print(\"❌ 没有有效的算法实例\")\n            return\n        \n        # 创建评估器\n        classifiers = [c.strip() for c in args.classifiers.split(',')]\n        evaluator = Evaluator(\n            classifiers=classifiers,\n            train_ratio=0.8,\n            random_state=42\n        )\n        \n        # 运行比较\n        print(\"\\n🏃 开始算法比较...\")\n        results = evaluator.compare_algorithms(algorithms, X, Y)\n        \n        # 打印报告\n        evaluator.print_comparison_report(results)\n        \n        # 保存结果\n        if args.save_results:\n            from config.config import DATA_CONFIG\n            output_path = DATA_CONFIG['results_dir']\n            save_results(results, args, output_path)\n        \n        total_time = time.time() - start_total\n        print(f\"\\n⏱️  总耗时: {total_time:.2f} 秒\")\n        print(\"\\n✅ 比较完成!\")\n        \n        # 给出建议\n        report = results['comparison_report']\n        if 'best_method' in report:\n            print(f\"\\n💡 建议:\")\n            if report['best_accuracy'] > 0.7:\n                print(f\"   🎯 {report['best_method']} 表现优秀 (准确率: {report['best_accuracy']:.1%})\")\n            elif report['best_accuracy'] > 0.5:\n                print(f\"   ⚠️  {report['best_method']} 表现一般，可考虑参数调优\")\n            else:\n                print(f\"   ❌ 所有方法表现较差，建议检查数据质量或尝试其他数据集\")\n            \n            # 效率建议\n            efficiency = report['efficiency_analysis']\n            fastest_method = min(efficiency.keys(), key=lambda k: efficiency[k]['training_time'])\n            if fastest_method != report['best_method']:\n                print(f\"   ⚡ 如果追求速度，推荐 {fastest_method} (快 {efficiency[fastest_method]['speedup']:.1f}x)\")\n    \n    except KeyboardInterrupt:\n        print(\"\\n⚠️  用户中断\")\n    except Exception as e:\n        print(f\"\\n❌ 运行出错: {e}\")\n        if args.verbose:\n            import traceback\n            traceback.print_exc()\n        return 1\n    \n    return 0\n\nif __name__ == \"__main__\":\n    exit(main())